# Use with Auth0

docs coming soon

### Default Auth0 params

By default `useAuth`'s Auth0 client uses these params:

```jsx
const params = {
    domain: auth0_domain,
    clientID: auth0_client_id,
    redirectUri: `${callback_domain}/auth0_callback`,
    audience: `https://${auth0_domain}/api/v2/`,
    responseType: "token id_token",
    scope: "openid profile email"
};
```

`domain` and `clientID` come from your props.

`redirectUri` is set to use the `auth0_callbackpage` on the current domain. Auth0 redirects here after users login so you can set cookies and stuff. useAuthwill handle this for you ‚úåÔ∏è

`audience` is set to use api/v2. I know this is necessary but honestly have been copypasting it through several of my projects.

`responseType` same here. I copy paste this from old projects so I figured it's a good default.

`scope` you need openid for social logins and to be able to fetch user profiles after authentication. Profile and Email too. You can add more via the `auth0_params` override.

PS:

`isAuthenticating` is a flag for checking whether or not `useAuth` is in the middle of validating login details. This allows you to then make requests to your user database and work out where to send users from the `auth0_callback` page, e.g. profile page or sign up.

```javascript
const Auth0CallbackPage = () => {
    const { user, isAuthenticating, handleAuthentication } = useAuth();
    const { loading, data, error } = useQuery(QUERY, {
        variables: { id: user.sub }
    });

    if (error) {
        return <h1>There was an error</h1>;
    }

    if (isAuthenticating || loading) {
        return (
            <h1>
                This is the auth callback page, you should be redirected
                immediately.
            </h1>
        );
    }

    const { user: dbUser } = data || {};
    const redirectUrl = dbUser ? "/app/profile" : "/app/signup";

    handleAuthentication({ postLoginRoute: redirectUrl });
};
```

## Checklist for configuring Auth0

There's a couple of required configurations you need to make in Auth0 to make useAuth run smoothly.

**Callback URLs**

You need to allow both local development and your production app in callback URLs. It's a whitelist that tells Auth0 that your login request is coming from the right source.

![](https://i.imgur.com/xz8UK8Z.png)

‚ö†Ô∏è **Allowed Web Origins**

useAuth avoids using local storage for secure tokens. For Auth0 to know that our `checkSession` request is coming from the right source, you need to add your URLs to allowed web origins.

![](https://i.imgur.com/w2mmHH1.png)

**Allowed logout urls**

After logging out, Auth0 redirects back to your app. Again, it needs to know you aren't up to anything shady. If you are getting 400 response errors on page load, this is the most likely culprit.

![](https://i.imgur.com/S160EiI.png)

# Tips & tricks

## Persisting login after refresh

**NB Make sure you're not blocking cookies! Extensions like privacy badger and the Brave browser will prevent Auth0 from setting cookies so refreshing between logins wont work**

After you've set everything up (and you're using social sign on methods) you'll notice that refreshing doesn't keep your user logged in... üëé

If you're using an IdP such as Google or Github to provide identity, you will need to register an app on Auth0 to enable this behaviour. The steps to create this behaviour are a bit nested in docs but can be achieved relatively simply by following the guide [`Set Up Social Connections`](https://auth0.com/docs/dashboard/guides/connections/set-up-connections-social) on the Auth0 site. The guide follows steps for Google sign on, your mileage with other providers may vary...

For a more detailed understanding of why this is happening you can have a read through [this section](https://auth0.com/blog/react-tutorial-building-and-securing-your-first-app/#Securing-your-React-App) of Auth0s guide to setting up a secure React application. (Pro tip: search for `Keeping Users Signed In after a Refresh` to jump straight to the section in question).

## User's access tokens

Since version 0.4.0 useAuth exposes the entire Auth0 authResult object so you can access your user's id or access token. This is useful when you have to log the user into your own backend as well as the frontend.

For reference:

-   https://github.com/Swizec/useAuth/issues/11
-   https://github.com/Swizec/useAuth/issues/22

Like this:

```javascript
function SomeComponent() {
    const { authResult } = useAuth();

    console.log(authResult.idToken);
    console.log(authResult.accessToken);
    // etc, I recommend printing the authResult object to see everything that's available
}
```

## Granular role-based permissions

Since version 0.7.0 useAuth supports role-based permissions. Using roles, you can granularly control which parts of your site are available to which users.

You'll need to add some config on Auth0 and when using useAuth.

### Set up a Auth0 Rule

Auth0 rules are little snippets of JavaScript that run when you request user data.

Go to `Rules` and click `Create Rule`. Start an empty rule and add this code:

```javascript
function (user, context, callback) {
  const namespace = 'https://YOUR_DOMAIN';
  const assignedRoles = (context.authorization || {}).roles;

  user.user_metadata = user.user_metadata || {};

  user.user_metadata.roles = assignedRoles;

  context.idToken[namespace + '/user_metadata'] = user.user_metadata;

  callback(null, user, context);
}
```

This rule adds user roles to their meta data. You have to define the `namespace`. Make sure it looks like a URL.

### Add customPropertyNamespace to AuthProvider

When rendering your `<AuthProvider>` add the custom property namespace. Make sure it matches the namespace you used above.

```javascript
export const wrapPageElement = ({ element, props }) => (
  <AuthProvider
    navigate={navigate}
    // ...
    customPropertyNamespace="https://YOUR_DOMAIN"
  >
```

### use isAuthorized to check role permissions

Now you can use `isAuthorized` to check if the current user has access to some part of your site.

```javascript
    // show something only if current user has Student role
        {isAuthorized("Student") ? (
          <Content
            {...props}
            fullwidth={fullwidth}
            menu={menu}
            setMenu={setMenu}
            nav={nav}
          />
        : null}

    // you can also use an OR'd array
    // show something if user has Student role OR Admin role
        {isAuthorized(["Student", "Admin"]) ? (
          <Content
            {...props}
            fullwidth={fullwidth}
            menu={menu}
            setMenu={setMenu}
            nav={nav}
          />
        : null}
```

If current user is authenticated _and_ has the `Student` role, show the content. Otherwise null.

For convenience you can also pass multiple roles to check with an OR condition. If any fit the current user, `isAuthorized` returns `true`.
